//
//  Floormaker.cpp
//  Floor-Generator
//
//  Created by Matthew Clark on 25/01/2016.
//  Copyright (c) 2016 Matthew Clark. All rights reserved.
//

#include "Floormaker.h"

Floormaker::Floormaker(int _sX, int _sY, float _fNum){
    floorNum = _fNum;
    grid = resizeGrid(_sX,_sY);
    while (!enoughRooms()) {
        grid = resizeGrid(_sX,_sY);
        generateSpawn();
        generateFloor();
    }
    createSpecialRooms();
}

//Main function to generate a floor
void Floormaker::generateFloor(){
    complete = false;
    while (!complete){
        if(grid[current.y][current.x]==1){
            searchRooms();
            createRooms();
        }
        if(checkRoomComplete()){
            if(spawnRoute.size()>0){
                moveOutOfRoom();
            }
            else{
                complete= true;
            }
        }
        else{
            vector<GridPos> availDir = searchRoomTypes(1);
            moveIntoRoom(availDir[rand()%availDir.size()]);
        }
    }
    grid[spawn.y][spawn.x] = 9;
}

//Resizes the grid to the size of the floor
vector<vector<int>> Floormaker::resizeGrid(int _sY, int _sX){
    vector<vector<int>> _grid;
    _grid.resize(_sY);
    for(auto &_y: _grid) _y.resize(_sX);
    return _grid;
}

//Generates a random position for spawn
void Floormaker::generateSpawn(){
    spawn.x = 3+rand()%(grid.size()-5);
    spawn.y = 3+rand()%(grid[0].size()-5);
    
    grid[spawn.y][spawn.x] = 1;
    current = spawn;
}

//Returns a 2d vector of the current grid for the floor
vector<vector<int>> Floormaker::getUnformattedGrid(){
    return grid;
}

vector<vector<int>> Floormaker::getGrid(){
    vector<vector<int>> _gr;
    bool state = false;
    int top, left, right, bottom;
    for(int i=0; i<grid[0].size(); i++){
        for(int j=0; j<grid.size(); j++){
            if(grid[j][i]!=0){
                if(!state){
                    bottom = j;
                    top = j;
                    left = i;
                    right = i;
                    state=true;
                }
                else{
                    if(j>=bottom){
                        bottom = j+1;
                    }
                    if(j<top){
                        top = j;
                    }
                    
                    if(i<left){
                        left = i;
                    }
                    if(i>=right){
                        right = i+1;
                    }
                }
            }
        }
    }
    _gr = resizeGrid(bottom-top,right-left);
    for(int i=left; i<right; i++){
        for(int j=top; j<bottom; j++){
            _gr[j-top][i-left] = grid[j][i];
        }
    }
    return _gr;
}

//Searches if rooms can be generated and adds to available rooms vector
void Floormaker::searchRooms(){
    if(checkSide(0,1)){
        availableRooms.push_back(0);
    }
    if(checkSide(0,-1)){
        availableRooms.push_back(1);
    }
    if(checkSide(1,0)){
        availableRooms.push_back(2);
    }
    if(checkSide(-1,0)){
        availableRooms.push_back(3);
    }
}

vector<GridPos> Floormaker::searchRoomTypes(int _type){
    vector<GridPos> _gr;
    if(grid[current.y+1][current.x]==_type){
        _gr.push_back(GridPos(0,1));
    }
    if(grid[current.y-1][current.x]==_type){
        _gr.push_back(GridPos(0,-1));
    }
    if(grid[current.y][current.x+1]==_type){
        _gr.push_back(GridPos(1,0));
    }
    if(grid[current.y][current.x-1]==_type){
        _gr.push_back(GridPos(-1,0));
    }
    return _gr;
}


void Floormaker::createSpecialRooms(){
    for(int i=5; i<8; i++){
        int randRoom = rand()%endRoomLocations.size();
        grid[endRoomLocations[randRoom].x][endRoomLocations[randRoom].y] = i;
        endRoomLocations.erase(endRoomLocations.begin()+randRoom);
    }
}

bool Floormaker::enoughRooms(){
    int numRooms = 0;
    int endRooms = 0;
    endRoomLocations.clear();
    for(int i=0; i<grid[0].size(); i++){
        for(int j=0; j<grid.size(); j++){
            if(grid[j][i]!=0){
                if(grid[j][i]==4){
                    endRooms++;
                    endRoomLocations.push_back(GridPos(j,i));
                }
                numRooms++;
            }
        }
    }
    
    cout<<numRooms<<" "<<endRooms<<endl;
    if(numRooms>=5 && endRooms>=3){
        return true;
    }
    return false;
}


//Creates rooms based on the rooms which have the ability to be generated
void Floormaker::createRooms(){
    //Counts number of rooms it has generated
    //Used when creating new rooms
    int roomsGenerated = 1;
    
    //Chooses a random room direction and checks if it can be randomly generated by using function (pow(0.9+((floorNum*1.3-spawnRoute.size())/10.0), spawnRoute.size())/pow(roomsGenerated,1/floorNum))
    while (availableRooms.size()>0) {
        int randRoom = rand()%availableRooms.size();
        GridPos _dir = chooseDirection(availableRooms[randRoom]);
        
        float randNum = (rand()%100)/100.0;
        
        float chanceOfSpawn = pow(0.9+((floorNum*1.3-spawnRoute.size())/10.0), spawnRoute.size())/pow(roomsGenerated,1/floorNum);
        
        
         /*-- Prints room chances
        cout<<"random room: "<<availableRooms[randRoom]<<", randNum: "<<randNum<<", Chance number: "<<chanceOfSpawn<<endl;
        
        cout<<spawnRoute.size()<<" -- "<<1/floorNum<<" -- "<<pow(roomsGenerated,1/floorNum)<<endl;
        //*/
        
        
        if(randNum<=chanceOfSpawn){
            grid[current.y+_dir.y][current.x+_dir.x]=1;
            roomsGenerated++;
        }
        availableRooms.erase(availableRooms.begin()+randRoom);
    }
}

//Checks if a room can be generated
bool Floormaker::checkSide(int _vert, int _hori){
    bool canGenerate = true; //Initialise canGenerate boolean
    
    //If the program has selected top or bottom sides of a room
    if(abs(_vert)==1){
        //Checks if rooms above or below are not free
        for(int i=-1; i<=1; i++){
            if(checkOutOfBoundsX(current.x, _vert, i)){
                canGenerate=false;
            }
        }
        //Check to stop dungeon from containing cycles
        if(checkOutOfBoundsY(current.y, _vert*2, 0)){
            canGenerate = false;
        }
    }
    else if(abs(_hori)==1){
        //Checks if rooms left or right are not free
        for(int i=-1; i<=1; i++){
            if(checkOutOfBoundsY(current.y, i, _hori)){
                canGenerate=false;
            }
        }
        //Check to stop dungeon from containing cycles
        if(checkOutOfBoundsX(current.x, 0, _hori*2)){
            canGenerate=false;
        }
    }
    return canGenerate;
}

bool Floormaker::checkOutOfBoundsX(int _pos, int _vert, int _hori){
    if(_pos+_hori>1 && _pos+_hori<grid.size()-1){
        if(grid[current.y+_vert][current.x+_hori]!=0){
            return true;
        }
            return false;
    }
    return true;
}

bool Floormaker::checkOutOfBoundsY(int _pos, int _vert, int _hori){
    if(_pos+_vert>1 && _pos+_vert<grid[0].size()-1){
        if(grid[current.y+_vert][current.x+_hori]!=0){
            return true;
        }
        return false;
    }
    return true;
}

//Return a relative position base on what room number is passed in
/*
 0=Right
 1=Left
 2=Down
 3=Up
 */
GridPos Floormaker::chooseDirection(int _val){
    GridPos _grPos;
    switch (_val) {
        case 0:
            _grPos= GridPos(1,0);
            break;
        case 1:
            _grPos= GridPos(-1,0);
            break;
        case 2:
            _grPos= GridPos(0,1);
            break;
        case 3:
            _grPos= GridPos(0,-1);
            break;
            
    }
    return _grPos;
}

bool Floormaker::checkRoomComplete(){
    
    vector<int> uncheckedRooms; //Vector to check what rooms are adjacent the current room
    
    //Loops through get type of room to check what is around it
    for(int i=0; i<4; i++){
        vector<GridPos> _temp = searchRoomTypes(i);
        for(int j=0; j<_temp.size(); j++){
            uncheckedRooms.push_back(i); //Adds room types to uncheckedRooms vector
        }
    }
    
    //Checks if any adjacent rooms are 1. If so then the room is not fully complete
    for(int i=0; i<uncheckedRooms.size(); i++){
        if(uncheckedRooms[i]==1){
            return false;
        }
    }
    return true;
}

void Floormaker::moveIntoRoom(GridPos _pos){
    grid[current.y][current.x] = 2;
    spawnRoute.push_back(current);
    current.add(_pos);
}

void Floormaker::moveOutOfRoom(){
    grid[current.y][current.x] = 3;
    
    //Check for end rooms
    if(searchRoomTypes(0).size()>=3){
        grid[current.y][current.x]=4;
    }
    
    current = spawnRoute[spawnRoute.size()-1];
    spawnRoute.erase(spawnRoute.end()-1);
}

//Prints out the current grid of the floor
void Floormaker::printGrid(){
    for(auto _x: grid){
        for(auto _y: _x){
            cout<<_y<<", ";
        }
        cout<<endl;;
    }
}